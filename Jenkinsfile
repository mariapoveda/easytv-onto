//
// This Jenkinsfile builds the ontology-publisher image, runs a test and when the test passes it publishes the image
// to the Docker Registry
//
def app

pipeline {

  agent none

  environment {
    LC_ALL = 'en_US.UTF-8'
    LANG = 'en_US.UTF-8'
    LANGUAGE = 'en_US.UTF-8'
    // ONTOLOGY_FAMILY = 'fibo'
    FIBO_BRANCH = 'master'
    ONTOLOGY_BUILDER_IMAGE = 'edmcouncil/ontology-publisher'
    REGISTRY = "https://registry.hub.docker.com"
  }

  options {

    buildDiscarder(
      logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '', numToKeepStr: '5')
    )
    //
    // We let each stage running on each jenkins slave / agent decide what to check out or not
    //
    skipDefaultCheckout()
    //
    // Skip stages once the build status has gone to UNSTABLE.
    //
    skipStagesAfterUnstable()
    //
    // There must be SOME limit, if it hangs or whatever then that's a bug and therefore cancel the job.
    //
    timeout(time: 23, unit: 'HOURS')
    //
    // Prepend all console output generated by the Pipeline run with the time at which the line was emitted
    //
    //timestamps()
    ansiColor('xterm')
  }

  stages {

    stage('Prepare') {
      agent {
        label 'docker'
      }
      environment {
        PATH = "$PATH:/usr/bin"
      }
      steps {
        echo 'PATH=' + env.PATH
        // echo 'ONTOLOGY_FAMILY=' + env.ONTOLOGY_FAMILY

        echo "Cleaning workspace:"
        sh 'rm -rf ${WORKSPACE}/* || true'
        echo "Done cleaning"

        //
        // Check out this repo in the publisher directory so that we're not copying the ontology-repo into
        // the image. We're building the image from the publisher directory.
        //
        dir('publisher') {
          checkout scm
          script {
            env.GIT_HASH_BUILDER = sh(
                    script: "#!/bin/sh -e\ngit show --oneline | head -1 | cut -d' ' -f1",
                    returnStdout: true
            ).trim()
          }

          echo "GIT_HASH_BUILDER=>${env.GIT_HASH_BUILDER}"
        }


    stage('Build Image 1') {
      agent {
        label 'docker'
      }
      steps {
        sh "docker build --tag ${env.ONTOLOGY_BUILDER_IMAGE}:${env.GIT_HASH_BUILDER} ."
      }
    }

    stage('Build image') {
      agent {
        dockerfile {
          filename 'Dockerfile'
          dir 'publisher'
          additionalBuildArgs '--pull --tag ${ONTOLOGY_BUILDER_IMAGE}:${GIT_HASH_BUILDER} '
        }
      }
      environment {
        PATH = "$PATH:/usr/bin"
      }
      //
      // Everything that happens below is done inside the container
      //
      steps {
        sh 'cd /publisher && ./publish.sh --help'
      }
    }

    stage('Test image') {
      agent {
        docker {
          image "${env.ONTOLOGY_BUILDER_IMAGE}:${env.GIT_HASH_BUILDER}"
        }
      }
      environment {
        PATH = "$PATH:/usr/bin"
      }
      //
      // Everything that happens below is done inside the container
      //
      steps {
        sh 'export | grep GIT_ ; cd /publisher && ./publish.sh index'
      }
    }

    stage('Publish Image') {
      agent {
        label 'docker'
      }
      when {
        branch 'master'
      }
      environment {1
        PATH = "$PATH:/usr/bin"
      }
      steps {
        echo "Now publish the image ${env.ONTOLOGY_BUILDER_IMAGE}"
        withDockerRegistry([
          credentialsId: 'docker-hub-credentials',
          url: ''
        ]) {
          sh "export"
          sh "docker push --help"
          sh "echo 1 ${env.ONTOLOGY_BUILDER_IMAGE}"
          sh 'echo 2 ${env.ONTOLOGY_BUILDER_IMAGE}'
          sh "echo 3 ${ONTOLOGY_BUILDER_IMAGE}"
          sh 'echo 4 ${ONTOLOGY_BUILDER_IMAGE}'
          sh "echo 5 \${ONTOLOGY_BUILDER_IMAGE}"
          sh "docker push ${env.ONTOLOGY_BUILDER_IMAGE}:${env.GIT_HASH_BUILDER}"
          sh "docker push ${env.ONTOLOGY_BUILDER_IMAGE}:latest"
        }
      }
    }
  }
}